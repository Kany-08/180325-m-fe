/**
 * Возвращает значение элемента массива по указанному индексу.
 *
 * Алгоритм:
 * 1. Возвращает элемент массива по индексу.
 *
 * @param {Array} arr - массив элементов
 * @param {number} index - индекс элемента
 * @return {*} значение элемента массива по указанному индексу
 */
export function getValueByIndex(arr, index) {
  if (!arr.length) {
    throw Error("Массив пуст");
  }
  if (index < 0 || index > arr.length - 1) {
    throw Error("Невалидный индекс массива");
  }
  return arr[index]; // O(1)
}

/**
 * Подсчитывает количество итераций, необходимых для уменьшения числа n до 1,
 * деля его на 2 на каждой итерации.
 *
 * Алгоритм:
 * 1. Инициализировать переменную `count` значением `0`.
 * 2. Начать цикл, пока `n` больше 1.
 * 3. На каждой итерации:
 *    1. Делить `n` на 2.
 *    2. Увеличивать `count` на 1.
 * 4. Вернуть `count`.
 *
 * @param {number} n - начальное число
 * @return {number} количество итераций
 */
export function calcLogarithm(n) {
  if (n <= 0) {
    throw Error ("Логарифм будем считать только для пололжительных чисел больше 0");
  }
  let count = 0;
  while (n > 1) {
    n = n /2;
    count++;
  }
  return count;
}

/**
 * Вычисляет факториал числа n.
 * Формула: n! = n * (n-1) * (n-2) * ... * 1
 *
 * Алгоритм:
 * 1. Проверить, что число неотрицательное.
 * 2. Если число отрицательное:
 *    1. Вернуть сообщение об ошибке.
 * 3. Если число равно 0 или 1:
 *    1. Вернуть 1.
 * 4. Инициализировать переменную `result` значением `1`.
 * 5. Начать цикл от 2 до n.
 * 6. Для каждого числа в цикле:
 *    1. Умножить `result` на текущее число.
 * 7. Вернуть `result`.
 *
 * @param {number} n - число для вычисления факториала
 * @return {number|string} факториал числа или сообщение об ошибке
 */
export function factorial(n) {
  if (n < 0) {
    throw Error("Факторил работает с положительными числами");
  }
  if (n === 0 || n === 1) {
    return 1;
  }
  let result = 1;
  for (let i = 2; i <= n; i++) {
    result = result * i;
  }
  return result; // O(n)
}

/**
 * Вычисляет n-е число Фибоначчи.
 * Формула: F(n) = F(n-1) + F(n-2), где F(0) = 0 и F(1) = 1
 *
 * Алгоритм:
 * 1. Проверить, что число неотрицательное.
 * 2. Если число отрицательное:
 *    1. Вернуть сообщение об ошибке.
 * 3. Если число равно 0 или 1:
 *    1. Вернуть само число.
 * 4. Инициализировать переменные `prev` и `current` значениями 0 и 1 соответственно.
 * 5. Начать цикл от 2 до n.
 * 6. Для каждого числа в цикле:
 *    1. Вычислить следующее число Фибоначчи как сумму `prev` и `current`.
 *    2. Обновить `prev` и `current`.
 * 7. Вернуть `current`.
 *
 * @param {number} n - индекс числа Фибоначчи
 * @return {number|string} n-е число Фибоначчи или сообщение об ошибке
 */
export function fibonacci(n) {
  throw Error('method fibonacci is not implemented yet');
}

/**
 * Сортирует массив методом пузырька.
 *
 * Алгоритм:
 * 1. Начать внешний цикл по элементам массива.
 * 2. Для каждого элемента:
 *    1. Начать внутренний цикл по элементам массива.
 *    2. Сравнивать соседние элементы.
 *    3. Если текущий элемент больше следующего, поменять их местами.
 * 3. Вернуть отсортированный массив.
 *
 * @param {Array<number>} arr - массив чисел
 * @return {Array<number>} отсортированный массив
 */
export function bubbleSort(arr) {
  throw Error('method bubbleSort is not implemented yet');
}

/**
 * Сортирует массив методом вставок.
 *
 * Алгоритм:
 * 1. Начать цикл со второго элемента массива.
 * 2. Для каждого элемента:
 *    1. Сохранить текущий элемент.
 *    2. Начать цикл с конца отсортированной части массива.
 *    3. Сдвигать элементы, которые больше текущего, вправо.
 *    4. Вставить текущий элемент на его место.
 * 3. Вернуть отсортированный массив.
 *
 * @param {Array<number>} arr - массив чисел
 * @return {Array<number>} отсортированный массив
 */
export function insertionSort(arr) {
  throw Error('method insertionSort is not implemented yet');
}

/**
 * Подсчитывает количество уникальных перестановок элементов массива.
 *
 * Алгоритм:
 * 1. Инициализировать переменную `count` значением `0`.
 * 2. Начать цикл по элементам массива.
 * 3. Для каждого элемента:
 *    1. Начать вложенный цикл по элементам массива.
 *    2. Пропустить итерации, если индексы совпадают.
 *    3. Увеличить `count` на 1 для каждой уникальной перестановки.
 * 4. Вернуть `count`.
 *
 * @return {number} количество уникальных перестановок
 */
export function permutation() {
  throw Error('method permutation is not implemented yet');
}


//console.log(" result = " + getValueByIndex([1, 2, 3, 4, 5, 6, 7], 2));
//console.log(" result = " + getValueByIndex([1, 2, 3, 4, 5, 6, 7, 1, 2, 3, 4, 5, 6, 7, 1, 2, 3, 4, 5, 6, 7, 1, 2, 3, 4, 5, 6, 7, 1, 2, 3, 4, 5, 6, 7, 1, 2, 3, 4, 5, 6, 7], 20));
//console.log(factorial(2));
//console.log(factorial(3));
//console.log(factorial(4));
//console.log(factorial(5));
//console.log(factorial(6));

console.log(calcLogarithm(16));
console.log(calcLogarithm(1024));
console.log(calcLogarithm(1));
console.log(calcLogarithm(0));